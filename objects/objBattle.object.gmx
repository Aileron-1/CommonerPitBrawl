<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// does all the battle-related stuff - client might need 
// to handle network outside of battle after all.
owner = 0;

// View initialize
view_xview[0] = 0;
view_yview[0] = 0;
view_wview[0] = 360;
view_hview[0] = 640;

// Load map - just generating it for now
gridWidth = 11;
gridHeight = 11;
gridRealWidth = (max(gridWidth,gridHeight)*64)+64;
gridRealHeight = (max(gridWidth,gridHeight)*32)+32;

map = ds_grid_create(gridWidth, gridHeight);
pathingGrid = ds_grid_create(gridWidth, gridHeight);
for (var i = 0; i &lt; gridWidth; i++) {
    for (var o = 0; o &lt; gridHeight; o++) {
        blockType = 1;
        if (o &gt;= 4 &amp;&amp; o &lt;= 5 &amp;&amp; i &lt;= 6 &amp;&amp; i &gt;= 2) blockType = 0;
        if (o &lt;= 7 &amp;&amp; o &gt;= 2 &amp;&amp; i == 8) blockType = 2;
        if (o &lt;= 6 &amp;&amp; o &gt;= 2 &amp;&amp; i == 9) blockType = 2;
        
        ds_grid_add(map, i, o, blockType);
    }
}

// Room resize to fit grid
padding = 200;
room_width = view_wview[0] + gridRealWidth + padding;
room_height = view_hview[0] + gridRealHeight + padding;

// Grid
global.gridX = view_wview[0] + ((room_width-view_wview[0])/2);
global.gridY = 100;
movePath = 0;

// Create Map blocks
blocks = ds_list_create();
for (var i = 0; i &lt; ds_grid_width(map); i++) {
    for (var o = 0; o &lt; ds_grid_height(map); o++) {
        pos = ToIsometric(i,o);
        if (map[# i, o] == 0) {
            //blocks[# i, o] = 0;
        }
        if (map[# i, o] == 1) {
            b = instance_create(global.gridX+pos[0], global.gridY+pos[1], objBlock);
            b.xx = i;
            b.yy = o;
            ds_list_add(blocks, b);
        }
        if (map[# i, o] == 2) {
            b = instance_create(global.gridX+pos[0], global.gridY+pos[1], objBlockWater);
            b.xx = i;
            b.yy = o;
            b.image_speed = 1/60;
            ds_list_add(blocks, b);
        }
    }
}

// Create selector
select = instance_create(0,0,objSelect);

// Make entities list
entities = ds_list_create();

// Remember player ID (when it gets sent to us)
player = 0;

// Put camera into the middle
view_xview[1] = view_wview[0] + ((room_width-view_wview[0])/2) - (view_wview[1]/2);

// Camera init
startPressed_x = mouse_x;
startPressed_y = mouse_y;
startView_x = view_xview[1];
startView_y = view_yview[1];
panning = 0;
scrollFactor = 10;
scrollLimit_lower = 200;
scrollLimit_upper = 480;

panLimit_left = view_hview[0] - (view_wport[1]/2) - 60;
panLimit_right = room_width - view_wview[1] - (view_wport[1]/2) + 120;
panLimit_upper = 0 - 100; 
panLimit_lower = gridRealHeight - view_hview[1] + 200;


// UI Buttons
// Action buttons
var buttonAction_x = 30+30;
var buttonAction_y = 640-80;
var buttonActionStep_x = 60 + 20
var index = 0;

button[0] = CreateButton(id, buttonAction_x+buttonActionStep_x*index, buttonAction_y, "Action", "action", 2);
button[0].toggle = 1;
index++;
button[1] = CreateButton(id, buttonAction_x+buttonActionStep_x*index, buttonAction_y, "Bonus", "bonusaction", 2);
button[1].toggle = 1;
index++;
button[2] = CreateButton(id, buttonAction_x+buttonActionStep_x*index, buttonAction_y, "Free", "freeaction", 2);
button[2].toggle = 1;
index++;
button[3] = CreateButton(id, buttonAction_x+buttonActionStep_x*index, buttonAction_y, "Move", "move", 2);
button[3].toggle = 1;

// End turn
button[4] = CreateButton(id, view_wview[0]/2, 50, "End Turn", "turn", 1);

// End of buttons
buttonListen = "";

// Button action indicators 
var index = 0;
indicator[index] = instance_create(button[index].x,button[index].y-5-30,objIndicator);
index++;
indicator[index] = instance_create(button[index].x,button[index].y-5-30,objIndicator);
index++;
indicator[index] = instance_create(button[index].x,button[index].y-5-30,objIndicator);
index++;
indicator[index] = instance_create(button[index].x,button[index].y-5-30,objIndicator);
indicator[index].image_index = 1;
indicator[index].labelSuffix = " ft";

// Actionlist Listener
actionListen = -1;

// Target mode tracker
targetMode = "";
targetLabel = '';

// Animation
animListen = "";

//canMove = 0;
toDraw[0,0] = 0;

// Turn baton
turn = 0;

// Event
turnAnim = 0;

// Create log
log = instance_create(0,view_yport[1],objLog);
log.owner = id;


// To Draw
toDrawRangeX = ds_list_create();
toDrawRangeY = ds_list_create();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Path calc
/*if (select.visible) {
    if (instance_exists(objPlayerClient)) {
        movePath = path_add();
        mp_grid_path(pathingGrid, movePath, player.x, player.y, select.block.xx, select.block.yy, 1);
    }
} 
else {
    if (path_exists(movePath)) {
        path_delete(movePath);
    }
}*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Scrolling
if (mouse_wheel_up()) {
    if (view_wview[1] &gt; scrollLimit_lower ) {
        view_wview[1] -= scrollFactor;
        view_hview[1] -= scrollFactor;
        view_xview[1] += scrollFactor/2;
        view_yview[1] += scrollFactor/2;
    }
}
if (mouse_wheel_down()) {
    if (view_wview[1] &lt; scrollLimit_upper ) {
        view_wview[1] += scrollFactor;
        view_hview[1] += scrollFactor;
        view_xview[1] -= scrollFactor/2;
        view_yview[1] -= scrollFactor/2;
    }
}

// Panning
if (!instance_exists(objPopup) || objPopup.visible == 0) {
    vMouseX = window_view_mouse_get_x(0);
    vMouseY = window_view_mouse_get_y(0);
    if (mouse_check_button_pressed(mb_left)) {
        if (mouse_y &lt; view_yport[1]+view_hport[1]) {
            startPressed_x = vMouseX;
            startPressed_y = vMouseY;
            startView_x = view_xview[1];
            startView_y = view_yview[1];
            panning = 1;
        }
    }
    if (panning == 1) {
        view_xview[1] = startView_x - (vMouseX - startPressed_x);
        view_yview[1] = startView_y - (vMouseY - startPressed_y);
    }
}
if (mouse_check_button_released(mb_left)) {
    panning = 0;
}

/*
if (!instance_exists(objPopup) || objPopup.visible == 0) {
    vMouseX = window_mouse_get_x();
    vMouseY = window_mouse_get_y();
    if (mouse_check_button_pressed(mb_left)) {
        if (mouse_y &lt; view_yport[1]+view_hport[1]) {
            startPressed_x = vMouseX;
            startPressed_y = vMouseY;
            startView_x = view_xview[1];
            startView_y = view_yview[1];
            panning = 1;
        }
    }
    if (panning == 1) {
        view_xview[1] = startView_x - (vMouseX - startPressed_x);
        view_yview[1] = startView_y - (vMouseY - startPressed_y);
    }
}
if (mouse_check_button_released(mb_left)) {
    panning = 0;
}*/


// Panning boundaries
panLimit_left = view_hview[0] - (view_wport[1]/2) - 100;
panLimit_right = room_width - view_wview[1] - (view_wport[1]/2) + 164;
panLimit_upper = 0 - 100; 
panLimit_lower = gridRealHeight - view_hview[1] + 200;
if (view_xview[1] &lt; panLimit_left) {
    view_xview[1] = panLimit_left;
}
if (view_xview[1] &gt; panLimit_right) {
    view_xview[1] = panLimit_right;
}
if (view_yview[1] &lt; panLimit_upper) {
    view_yview[1] = panLimit_upper;
}
if (view_yview[1] &gt; panLimit_lower) {
    view_yview[1] = panLimit_lower;
}

// if Attack is on
if (targetMode == 'Attack') {
    // Select
    with (select) {
        visible = 0;
        block = collision_point(mouse_x,mouse_y,objBlock,1,0);
        if (block) {
            x = block.x;
            y = block.y;
            xx = block.xx;
            yy = block.yy;
            visible = 1;
        }/*
        else {
            visible = 0;
        }*/
    }
    
                                    // Make into script later
    // Show attack range
    var atkRange = 1;
    for (var i = 0; i &lt; ds_list_size(blocks); i++) { 
        blocks[|i].selected = 0;
        var xDist = abs(player.xx-blocks[|i].xx);
        var yDist = abs(player.yy-blocks[|i].yy);
        if (xDist+yDist &lt;= atkRange) blocks[|i].selected = 1;
        // JUST FOR FUN //if (xDist+yDist == 0) blocks[|i].selected = 0;
    }
    
    // Click
    if (mouse_check_button_pressed(mb_left)) {
        if (mouse_y &lt; view_yport[1]+view_hport[1]) {
            if (mouse_y &gt; view_yport[1]) {
                block = collision_point(mouse_x,mouse_y,objBlock,1,0);
                if (block) {
                    // Do it
                    with (owner) {SendAttack(battle.block.xx,battle.block.yy,0);}
                    
                }
                targetMode = '';
            }
        }
    }
}
// if Move is on
else if (targetMode == 'Move') {
    // Select
    with (select) {
        block = collision_point(mouse_x,mouse_y,objBlock,1,0);
        if (block) {
            x = block.x;
            y = block.y;
            xx = block.xx;
            yy = block.yy;
            visible = 1;
        }
        else {
            visible = 0;
        }
    }
    
    // Show moverange (hacked)
    for (var i = 0; i &lt; ds_list_size(blocks); i++) { 
        blocks[|i].selected = 0;
        var xDist = abs(player.xx-blocks[|i].xx);
        var yDist = abs(player.yy-blocks[|i].yy);
        if (xDist+yDist &lt;= player.movement/BLOCK_FT) blocks[|i].selected = 1;
        if (xDist+yDist == 0) blocks[|i].selected = 0;
        if (blocks[|i].object_index == objBlockWater) blocks[|i].selected = 0;
    }
    
    // Click
    if (mouse_check_button_pressed(mb_left)) {
        if (mouse_y &lt; view_yport[1]+view_hport[1]) {
        if (mouse_y &gt; view_yport[1]) {
            block = collision_point(mouse_x,mouse_y,objBlock,1,0);
            if (block) {
                if (player) {
// New Note. server-enforced move ranges. Command can be performed by player whenever. 
// It just won't necessarily be accepted
                    // Use hacky clientside movement ranges. Change later
                    // And hacky 2 move limit
                    var xDist = abs(player.xx-block.xx);
                    var yDist = abs(player.yy-block.yy);
                    if (block.selected) {
                        //if (xDist+yDist &lt;= player.movement/BLOCK_FT) {
                            // using 1 movement as placeholder before movement ranges
                            //if (player.movement &gt; 0) {
                                //player.movement -= xDist+yDist*BLOCK_FT;
                                with (owner) {
                                    SendMoveTo(battle.block.xx, battle.block.yy,1);
                                }
                            //}
                        //}
                    }
                }
            }
            targetMode = '';
            button[3].image_index = 0;
        }
        }
    }
}
else {
    for (var i = 0; i &lt; ds_list_size(blocks); i++) { 
        blocks[|i].selected = 0;
    }
    select.visible = 0;
}

// Button stuff
// If action open
                            // note: flip IFs for code consistency
if (instance_exists(objActionList)) {
    if (actionList.closeTrigger == 1) {
        button[0].image_index = 0;
        actionList.closeTrigger = 0;
    }
    
    if (button[0].image_index == 2) {
        actionList.visible = 1;
        button[1].image_index = 0;
        button[2].image_index = 0;
        button[3].image_index = 0;
    }
    else {
        actionList.visible = 0;
    }
}
if (button[0].image_index == 2) {
    if (!instance_exists(objActionList)) {
        // Action list
        actionList = instance_create(30,320,objActionList);
        actionList.owner = id;
        actionList.visible = 0;
    }
}

// Move 
if (button[3].image_index == 2) {
    if (targetMode == '') {
        targetMode = 'Move';
        targetLabel = 'Select tile to move to.';
    }
}
else {
    if (targetMode == 'Move') {
        targetMode = '';
    }
}

// Buttons
switch (buttonListen) {
case "action":
    buttonListen = "";
    break;
case "move": 
    if (button[3].image_index == 0) {
        buttonListen = "";
        break;
    }
    if (button[3].image_index == 2) {
        buttonListen = "";
        break;
    }
    break;
case "turn": 
    // send end turn packet, hope to get actions back from server
    with (owner) {SendTurn();}
    turn = 0;
    turnAnim = 0;  // get anim ready for another one
    buttonListen = "";
    break;
}

// No buttons if turn isn't real
for (var i=0; i&lt;5; i++) {
    button[i].visible = turn;
    if (i &lt;= 3) {
        indicator[i].visible = turn;
    }
}

// Update indicator texts
if (player) {
    indicator[0].label = player.action[0];
    indicator[1].label = player.action[1];
    indicator[2].label = player.action[2];
    indicator[3].label = player.movement;
}

if (turnAnim == 0) {
    if (turn == 1) {
        CreateCutIn(id,"Your Turn","turn");
        turnAnim = 1;
    }
}

// Animation
switch (animListen) {
case "turn":
    turnAnim = 2;
break;
}

/*
if (turnAnim &gt;= 1) {
    // do turn animation
    
    //turnAnim += 1;
    
    turnAnim = -1;
}*/


// Actions. Check trigger
switch (actionListen) {
    case 'Dash':
        with (owner) {SendDash();}
        targetMode = '';
        button[3].image_index = 2;
        break;
    
    case 'Attack':
        targetMode = 'Attack';
        targetLabel = 'Select tile to attack.';
        break;
}
actionListen = "";


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Draw camera lines
/*
draw_set_color(c_white);
draw_rectangle(view_xport[1], view_yport[1], view_xport[1]+view_wport[1], view_yport[1]+view_hport[1], 1)
*/
// Top UI panel
//draw_set_color(make_colour_hsv(52,83,181));
draw_set_color(make_colour_rgb(235, 230, 198));
draw_rectangle(view_xview[0], view_yview[0], view_xport[1]+view_wport[1], view_yport[1], 0);

// Draw bottom UI panel
//draw_set_color(make_colour_hsv(52,255,158));
draw_rectangle(view_xport[1], view_yport[1]+view_hport[1], view_xview[0]+view_wview[0], view_yview[0]+view_hview[0], 0)


// Targeting status
//if (button[3].image_index == 2) {
if (targetMode != '') {
    draw_set_color(c_black);
    draw_set_alpha(0.5);
    draw_rectangle(view_wview[0]/2-110, view_yport[1]+view_hport[1]-33-12, view_wview[0]/2+110, view_yport[1]+view_hport[1]-33+12,0);
    draw_set_alpha(1);
    
    draw_set_halign(fa_middle);
    draw_set_font(font0);
    draw_set_color(c_white);
    draw_text(view_wview[0]/2, view_yport[1]+view_hport[1]-33, targetLabel);
}

// Draw Waiting on other player's turn
if (turn == 0) {
    var txt = "Waiting on other turns...";
    draw_set_font(font3);
    draw_set_color(c_white);
    draw_set_halign(fa_middle);
    draw_text(360/2,550,txt);
}


//draw_sprite(sprInitiative,0,0,0);


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*
if (path_exists(movePath)) {
    for (var i = 0; i &lt; path_get_length(movePath)+1; i++) {
        show_debug_message(path_get_length(movePath))
        show_debug_message(i)
        ex = path_get_x(movePath, i/path_get_length(movePath)+1);
        ey = path_get_y(movePath, i/path_get_length(movePath)+1);
        draw_sprite(sprSelectRange,0,ex,ey);
    }
}*/
/*
var r = player.movement*2+1;
for (var i = 0; i &lt; r; i++) {
    for (var o = 0; o &lt; r; o++) {
        if (toDraw[i,o] == 1) {
            pos = ToIsometric(i-player.movement,o-player.movement);
            draw_sprite(sprSelect,0,pos[0]+player.x,pos[1]+player.y);
        }
    }
}*/
/*
player.xx-1
player.xx+1
player.yy-1
player.yy+1
*/




</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
